# VERSION: 8d9d65d
# THIS FILE IS AUTOGENERATED - DO NOT MODIFY TEMPLATE HOOKS
# Source: https://github.com/Software-Automation-Holdings-LLC/developer-common/blob/8d1fc342aa011694119f8ed188fe04e1b4790d56/pre-commit-configs/

# === TEMPLATE HOOKS (DO NOT MODIFY) ===

repos:
  # From base.yaml
  # General file checks
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v5.0.0
    hooks:
      - id: trailing-whitespace
        # Skip autogenerated files
        entry: |
          bash -c '
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          exec trailing-whitespace-fixer "${FILTERED_FILES[@]}"
          ' --
      - id: end-of-file-fixer
        # Skip autogenerated files
        entry: |
          bash -c '
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          exec end-of-file-fixer "${FILTERED_FILES[@]}"
          ' --
      - id: check-yaml
        # Skip autogenerated files (but still validate syntax)
        entry: |
          bash -c '
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          exec check-yaml "${FILTERED_FILES[@]}"
          ' --
      - id: check-json
        # Skip autogenerated files (check manifest for JSON files, header for others)
        entry: |
          python3 -c "
          import sys
          import json
          import os
          from pathlib import Path

          manifest_file = '.sah-defaults-versions.json'
          filtered_files = []

          # Load manifest if it exists
          manifest = {}
          if os.path.exists(manifest_file):
              try:
                  with open(manifest_file) as f:
                      manifest = json.load(f)
              except:
                  pass

          for file_path in sys.argv[1:]:
              # Skip manifest file itself
              if '.sah-defaults-versions.json' in file_path:
                  continue

              file_path_obj = Path(file_path)
              filename = file_path_obj.name

              # For JSON files, check if they're in the manifest (autogenerated)
              if file_path.endswith('.json') and filename in manifest:
                  continue

              # For non-JSON or files not in manifest, check for header
              try:
                  with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                      first_lines = ''.join(f.readline() for _ in range(10))
                      if 'THIS FILE IS AUTOGENERATED' not in first_lines:
                          filtered_files.append(file_path)
              except:
                  # If we can't read it, include it to be safe
                  filtered_files.append(file_path)

          if not filtered_files:
              sys.exit(0)

          # Run check-json on filtered files
          import subprocess
          sys.exit(subprocess.run(['check-json'] + filtered_files).returncode)
          " --
      - id: check-added-large-files
      - id: check-merge-conflict
      - id: check-case-conflict
      - id: mixed-line-ending
        # Skip autogenerated files
        entry: |
          bash -c '
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          exec mixed-line-ending "${FILTERED_FILES[@]}" --fix=lf
          ' --
      - id: detect-private-key

  # Git commit message format
  - repo: https://github.com/commitizen-tools/commitizen
    rev: v4.10.0
    hooks:
      - id: commitizen
        stages: [commit-msg]


  # From css.yaml
  # Stylelint - CSS/SCSS auto-fixer and linter (warnings only for remaining issues)
  - repo: https://github.com/thibaudcolas/pre-commit-stylelint
    rev: v16.6.1
    hooks:
      - id: stylelint
        name: stylelint (auto-fix, warnings only)
        types_or: [css, scss]
        additional_dependencies:
          - stylelint@16.6.1
          - stylelint-config-standard@36.0.0
        args: ["--fix"]
        # Skip if no stylelint config file exists
        # Auto-fix runs, but remaining lint issues are warnings (non-blocking)
        entry: |
          bash -c '
          if [ ! -f .stylelintrc.json ] && [ ! -f .stylelintrc.js ] && [ ! -f .stylelintrc.yaml ] && [ ! -f .stylelintrc.yml ] && [ ! -f stylelint.config.js ] && [ ! -f stylelint.config.mjs ] && [ ! -f stylelint.config.cjs ]; then
            echo "Skipping stylelint: No configuration file found (.stylelintrc.json, stylelint.config.js, etc.)"
            exit 0
          fi
          # Auto-fix issues first, then show remaining issues as warnings (non-blocking)
          stylelint --fix "$@" || true
          stylelint "$@" || echo "⚠️  Stylelint found issues (non-blocking warning)"
          exit 0
          ' --


  # From go.yaml
  - repo: local
    hooks:
      - id: go-fmt
        name: go fmt
        entry: sh -c 'gofmt -w "$@"' --
        language: system
        types: [go]
        pass_filenames: true
      - id: go-vet
        name: go vet
        entry: sh -c 'go vet ./...'
        language: system
        types: [go]
        pass_filenames: false
      - id: go-imports
        name: goimports
        entry:
          sh -c 'if command -v goimports >/dev/null 2>&1; then goimports -w "$@"; else go run
          golang.org/x/tools/cmd/goimports@latest -w "$@"; fi' --
        language: system
        types: [go]
        pass_filenames: true
      - id: go-mod-tidy
        name: go mod tidy
        entry: sh -c 'go mod tidy'
        language: system
        files: ^go\.(mod|sum)$
        pass_filenames: false
      - id: golangci-lint
        name: golangci-lint
        entry:
          sh -c 'if command -v golangci-lint >/dev/null 2>&1; then golangci-lint run --timeout=5m;
          else echo "golangci-lint not found, skipping"; fi'
        language: system
        types: [go]
        pass_filenames: false


  # From html.yaml
  # Prettier - HTML formatter (local hook since mirrors-prettier is archived)
  - repo: local
    hooks:
      - id: prettier-html
        name: prettier
        entry: |
          bash -c '
          # Check if prettier is available
          if ! command -v npx >/dev/null 2>&1; then
            echo "npx not found, skipping prettier"
            exit 0
          fi
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          npx prettier@3.4.2 --write "${FILTERED_FILES[@]}"
          ' --
        language: system
        types: [html]


  # From javascript.yaml
  - repo: https://github.com/pre-commit/mirrors-eslint
    rev: v9.15.0
    hooks:
      - id: eslint
        name: eslint (auto-fix, warnings only)
        types: [file]
        types_or: [javascript, jsx, ts, tsx]
        additional_dependencies:
          - eslint@9.15.0
        exclude: ^(node_modules|dist|build)/
        # Skip if no eslint config file exists, and skip autogenerated files
        # Auto-fix runs, but remaining lint issues are warnings (non-blocking)
        entry: |
          bash -c '
          # First check if eslint config exists (prefer flat config, fallback to legacy)
          if [ ! -f eslint.config.js ] && [ ! -f eslint.config.mjs ] && [ ! -f eslint.config.cjs ] && [ ! -f .eslintrc.json ] && [ ! -f .eslintrc.js ] && [ ! -f .eslintrc.yaml ] && [ ! -f .eslintrc.yml ] && [ ! -f .eslintrc.cjs ] && [ ! -f .eslintrc.mjs ] && [ ! -f package.json ]; then
            echo "Skipping eslint: No configuration file found (eslint.config.*, .eslintrc.*, or package.json with eslintConfig)"
            exit 0
          fi
          # Check if package.json has eslintConfig
          if [ -f package.json ] && ! grep -q "\"eslintConfig\"" package.json && [ ! -f eslint.config.js ] && [ ! -f eslint.config.mjs ] && [ ! -f eslint.config.cjs ] && [ ! -f .eslintrc.json ] && [ ! -f .eslintrc.js ] && [ ! -f .eslintrc.yaml ] && [ ! -f .eslintrc.yml ] && [ ! -f .eslintrc.cjs ] && [ ! -f .eslintrc.mjs ]; then
            echo "Skipping eslint: No configuration file found (eslint.config.*, .eslintrc.*, or package.json with eslintConfig)"
            exit 0
          fi
          # Filter out autogenerated files
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          # ESLint 9.0.0 uses flat config by default (eslint.config.js)
          # For legacy .eslintrc.* files, set ESLINT_USE_FLAT_CONFIG=false
          # Auto-fix issues first, then show remaining issues as warnings (non-blocking)
          if [ -f .eslintrc.json ] || [ -f .eslintrc.js ] || [ -f .eslintrc.yaml ] || [ -f .eslintrc.yml ] || [ -f .eslintrc.cjs ] || [ -f .eslintrc.mjs ]; then
            ESLINT_USE_FLAT_CONFIG=false eslint --fix "${FILTERED_FILES[@]}" || true
            ESLINT_USE_FLAT_CONFIG=false eslint "${FILTERED_FILES[@]}" || echo "⚠️  ESLint found issues (non-blocking warning)"
          else
            eslint --fix "${FILTERED_FILES[@]}" || true
            eslint "${FILTERED_FILES[@]}" || echo "⚠️  ESLint found issues (non-blocking warning)"
          fi
          exit 0
          ' --


  # From json.yaml
  # Prettier - JSON formatter (local hook since mirrors-prettier is archived)
  - repo: local
    hooks:
      - id: prettier-json
        name: prettier
        entry: |
          python3 -c "
          import sys
          import json
          import os
          import subprocess
          from pathlib import Path

          manifest_file = '.sah-defaults-versions.json'
          filtered_files = []

          # Load manifest if it exists
          manifest = {}
          if os.path.exists(manifest_file):
              try:
                  with open(manifest_file) as f:
                      manifest = json.load(f)
              except:
                  pass

          for file_path in sys.argv[1:]:
              # Skip manifest file itself
              if '.sah-defaults-versions.json' in file_path:
                  continue

              file_path_obj = Path(file_path)
              filename = file_path_obj.name

              # For JSON files, check if they're in the manifest (autogenerated)
              if file_path.endswith('.json') and filename in manifest:
                  continue

              # For non-JSON or files not in manifest, check for header
              try:
                  with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                      first_lines = ''.join(f.readline() for _ in range(10))
                      if 'THIS FILE IS AUTOGENERATED' not in first_lines:
                          filtered_files.append(file_path)
              except:
                  # If we can't read it, include it to be safe
                  filtered_files.append(file_path)

          if not filtered_files:
              sys.exit(0)

          # Run prettier on filtered files
          subprocess.run(['npx', 'prettier@3.4.2', '--write'] + filtered_files, check=False)
          " --
        language: system
        types: [json]
        exclude: ^\.sah-defaults-versions\.json$


  # From perl.yaml
  # Perl::Critic - Perl code quality checker
  - repo: local
    hooks:
      - id: perl-critic
        name: Perl::Critic
        entry: perlcritic
        language: system
        types: [perl] # Automatically skips if no Perl files are staged
        args: ["--quiet", "--profile", ".perlcriticrc"]
        exclude: ^(t/|xt/|blib/|_build/|local/|vendor/)

  # Perl::Tidy - Perl code formatter
  - repo: local
    hooks:
      - id: perl-tidy
        name: Perl::Tidy
        entry: perltidy
        language: system
        types: [perl] # Automatically skips if no Perl files are staged
        args: ["--profile=.perltidyrc", "--backup-and-modify-in-place"]
        exclude: ^(t/|xt/|blib/|_build/|local/|vendor/)


  # From python.yaml
  # Black - Python code formatter (required)
  - repo: https://github.com/psf/black
    rev: 24.10.0
    hooks:
      - id: black
        language_version: python3
        exclude: ^(migrations|venv|\.venv)/

  # isort - Python import sorter (required)
  - repo: https://github.com/pycqa/isort
    rev: 6.0.0
    hooks:
      - id: isort
        args: ["--profile", "black"]
        exclude: ^(migrations|venv|\.venv)/

  # flake8 - Python linter (warnings only, non-blocking)
  - repo: local
    hooks:
      - id: flake8
        name: flake8 (warnings only)
        language: system
        types: [python]
        exclude: ^(migrations|venv|\.venv)/
        entry: |
          bash -c '
          if ! command -v flake8 >/dev/null 2>&1; then
            echo "flake8 not found, skipping"
            exit 0
          fi
          flake8 --max-line-length=88 --extend-ignore=E203,W503 "$@" || echo "⚠️  flake8 found issues (non-blocking warning)"
          exit 0
          ' --


  # From ruby.yaml
  - repo: local
    hooks:
      - id: rubocop
        name: RuboCop
        description: Ruby linter and formatter
        entry: bundle exec rubocop --autocorrect --force-exclusion
        language: system
        types: [ruby]
        exclude: ^(vendor|node_modules|db/schema\.rb)/

      - id: rubocop-lint
        name: RuboCop (lint only)
        description: Ruby linter (no auto-fix, for CI)
        entry: bundle exec rubocop --force-exclusion
        language: system
        types: [ruby]
        exclude: ^(vendor|node_modules|db/schema\.rb)/
        stages: [manual]

      - id: erb-lint
        name: ERB Lint
        description: Lint ERB templates
        entry: bundle exec erblint --autocorrect
        language: system
        types: [erb]
        exclude: ^(vendor|node_modules)/
        require_serial: true


  # From shell.yaml
  # ShellCheck - Shell script static analysis (warning only, non-blocking)
  - repo: local
    hooks:
      - id: shellcheck
        name: shellcheck (warnings only)
        language: system
        types: [shell]
        entry: |
          bash -c '
          if ! command -v shellcheck >/dev/null 2>&1; then
            echo "shellcheck not found, skipping"
            exit 0
          fi
          shellcheck "$@" || echo "⚠️  ShellCheck found issues (non-blocking warning)"
          exit 0
          ' --


  # From terraform.yaml
  # Terraform formatting and validation
  - repo: https://github.com/antonbabenko/pre-commit-terraform
    rev: v1.100.0
    hooks:
      - id: terraform_fmt
        args:
          - --args=-recursive

      - id: terraform_validate

  # Terraform documentation generation
  - repo: https://github.com/terraform-docs/terraform-docs
    rev: v0.20.0
    hooks:
      - id: terraform-docs-system


  # From wordpress.yaml
  # WordPress Coding Standards
  - repo: local
    hooks:
      - id: phpcbf
        name: PHP Code Beautifier and Fixer (WordPress Coding Standards)
        entry: |
          bash -c '
          # Check if composer.json exists and has wordpress-plugin or wordpress-theme type
          if [ ! -f composer.json ]; then
            echo "Skipping PHPCBF: composer.json not found"
            exit 0
          fi

          # Check composer.json type using jq if available, otherwise use grep
          if command -v jq >/dev/null 2>&1; then
            COMPOSER_TYPE=$(jq -r ".type // empty" composer.json)
          else
            COMPOSER_TYPE=$(grep -o "\"type\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" composer.json | sed -n "s/.*\"type\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p" | head -1)
          fi

          if [ "$COMPOSER_TYPE" != "wordpress-plugin" ] && [ "$COMPOSER_TYPE" != "wordpress-theme" ]; then
            echo "Skipping PHPCBF: composer.json type is \"$COMPOSER_TYPE\" (expected wordpress-plugin or wordpress-theme)"
            exit 0
          fi

          if command -v phpcbf >/dev/null 2>&1; then
            phpcbf --standard=WordPress --extensions=php --ignore='*/vendor/*,*/node_modules/*,*/dist/*,*/build/*' "$@"
          elif [ -f vendor/bin/phpcbf ]; then
            ./vendor/bin/phpcbf --standard=WordPress --extensions=php --ignore='*/vendor/*,*/node_modules/*,*/dist/*,*/build/*' "$@"
          else
            echo "PHPCBF not found. Install with: composer require --dev squizlabs/php_codesniffer wp-coding-standards/wpcs"
            exit 1
          fi
          ' --
        language: system
        types: [php]
        require_serial: false
        pass_filenames: true
        always_run: false
      - id: phpcs
        name: PHP CodeSniffer (WordPress Coding Standards)
        entry: |
          bash -c '
          # Check if composer.json exists and has wordpress-plugin or wordpress-theme type
          if [ ! -f composer.json ]; then
            echo "Skipping PHPCS: composer.json not found"
            exit 0
          fi

          # Check composer.json type using jq if available, otherwise use grep
          if command -v jq >/dev/null 2>&1; then
            COMPOSER_TYPE=$(jq -r ".type // empty" composer.json)
          else
            COMPOSER_TYPE=$(grep -o "\"type\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" composer.json | sed -n "s/.*\"type\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p" | head -1)
          fi

          if [ "$COMPOSER_TYPE" != "wordpress-plugin" ] && [ "$COMPOSER_TYPE" != "wordpress-theme" ]; then
            echo "Skipping PHPCS: composer.json type is \"$COMPOSER_TYPE\" (expected wordpress-plugin or wordpress-theme)"
            exit 0
          fi

          if command -v phpcs >/dev/null 2>&1; then
            phpcs --standard=WordPress --extensions=php --ignore='*/vendor/*,*/node_modules/*,*/dist/*,*/build/*' "$@"
          elif [ -f vendor/bin/phpcs ]; then
            ./vendor/bin/phpcs --standard=WordPress --extensions=php --ignore='*/vendor/*,*/node_modules/*,*/dist/*,*/build/*' "$@"
          else
            echo "PHPCS not found. Install with: composer require --dev squizlabs/php_codesniffer wp-coding-standards/wpcs"
            exit 1
          fi
          ' --
        language: system
        types: [php]
        require_serial: false
        pass_filenames: true
        always_run: false


  # From xml.yaml
  # xmllint - XML validator and formatter (local hook for proper in-place formatting)
  - repo: local
    hooks:
      - id: format-xmllint
        name: Formats XML files
        entry: |
          bash -c '
          # Check if xmllint is available
          if ! command -v xmllint >/dev/null 2>&1; then
            echo "xmllint not found, skipping"
            exit 0
          fi
          FILTERED_FILES=()
          for file in "$@"; do
            # Skip autogenerated files
            if head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              continue
            fi
            FILTERED_FILES+=("$file")
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          # Format each file in place using temp file (xmllint does not support -i)
          for f in "${FILTERED_FILES[@]}"; do
            xmllint --format "$f" > "$f.xmltmp" 2>/dev/null && mv "$f.xmltmp" "$f" || rm -f "$f.xmltmp"
          done
          ' --
        language: system
        types: [xml]
        exclude: \.svg$


  # From yaml-markdown.yaml
  # Prettier - YAML and Markdown formatter (local hook since mirrors-prettier is archived)
  - repo: local
    hooks:
      - id: prettier-yaml-markdown
        name: prettier
        entry: |
          bash -c '
          # Check if prettier is available
          if ! command -v npx >/dev/null 2>&1; then
            echo "npx not found, skipping prettier"
            exit 0
          fi
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          npx prettier@3.4.2 --write "${FILTERED_FILES[@]}"
          ' --
        language: system
        types_or: [yaml, markdown]
        exclude: ^(CHANGELOG|LICENSE)



# === CUSTOM HOOKS (SAFE TO MODIFY BELOW) ===
# Add repo-specific hooks here.
