# VERSION: c1491cb
# THIS FILE IS AUTOGENERATED - DO NOT MODIFY TEMPLATE HOOKS
# Source: https://github.com/Software-Automation-Holdings-LLC/developer-common/blob/f5d26e0eb34a6ad25a1531c70c088872505f5820/pre-commit-configs/

# === TEMPLATE HOOKS (DO NOT MODIFY) ===

repos:
  # From base.yaml
  # General file checks
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v5.0.0
    hooks:
      - id: trailing-whitespace
        # Skip autogenerated files
        entry: |
          bash -c '
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          exec trailing-whitespace-fixer "${FILTERED_FILES[@]}"
          ' --
      - id: end-of-file-fixer
        # Skip autogenerated files
        entry: |
          bash -c '
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          exec end-of-file-fixer "${FILTERED_FILES[@]}"
          ' --
      - id: check-yaml
        # Skip autogenerated files (but still validate syntax)
        entry: |
          bash -c '
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          exec check-yaml "${FILTERED_FILES[@]}"
          ' --
      - id: check-json
        # Skip autogenerated files (check manifest for JSON files, header for others)
        entry: |
          python3 -c "
          import sys
          import json
          import os
          from pathlib import Path

          manifest_file = '.sah-defaults-versions.json'
          filtered_files = []

          # Load manifest if it exists
          manifest = {}
          if os.path.exists(manifest_file):
              try:
                  with open(manifest_file) as f:
                      manifest = json.load(f)
              except:
                  pass

          for file_path in sys.argv[1:]:
              # Skip manifest file itself
              if '.sah-defaults-versions.json' in file_path:
                  continue

              file_path_obj = Path(file_path)
              filename = file_path_obj.name

              # For JSON files, check if they're in the manifest (autogenerated)
              if file_path.endswith('.json') and filename in manifest:
                  continue

              # For non-JSON or files not in manifest, check for header
              try:
                  with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                      first_lines = ''.join(f.readline() for _ in range(10))
                      if 'THIS FILE IS AUTOGENERATED' not in first_lines:
                          filtered_files.append(file_path)
              except:
                  # If we can't read it, include it to be safe
                  filtered_files.append(file_path)

          if not filtered_files:
              sys.exit(0)

          # Run check-json on filtered files
          import subprocess
          sys.exit(subprocess.run(['check-json'] + filtered_files).returncode)
          " --
      - id: check-added-large-files
      - id: check-merge-conflict
      - id: check-case-conflict
      - id: mixed-line-ending
        # Skip autogenerated files
        entry: |
          bash -c '
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          exec mixed-line-ending "${FILTERED_FILES[@]}" --fix=lf
          ' --
      - id: detect-private-key

  # Git commit message format
  - repo: https://github.com/commitizen-tools/commitizen
    rev: v4.10.0
    hooks:
      - id: commitizen
        stages: [commit-msg]


  # From css.yaml
  # Stylelint - CSS/SCSS auto-fixer and linter (warnings only for remaining issues)
  - repo: https://github.com/thibaudcolas/pre-commit-stylelint
    rev: v16.6.1
    hooks:
      - id: stylelint
        name: stylelint (auto-fix, warnings only)
        types_or: [css, scss]
        additional_dependencies:
          - stylelint@16.6.1
          - stylelint-config-standard@36.0.0
        args: ["--fix"]
        # Skip if no stylelint config file exists
        # Auto-fix runs, but remaining lint issues are warnings (non-blocking)
        entry: |
          bash -c '
          if [ ! -f .stylelintrc.json ] && [ ! -f .stylelintrc.js ] && [ ! -f .stylelintrc.yaml ] && [ ! -f .stylelintrc.yml ] && [ ! -f stylelint.config.js ] && [ ! -f stylelint.config.mjs ] && [ ! -f stylelint.config.cjs ]; then
            echo "Skipping stylelint: No configuration file found (.stylelintrc.json, stylelint.config.js, etc.)"
            exit 0
          fi
          # Auto-fix issues first, then show remaining issues as warnings (non-blocking)
          stylelint --fix "$@" || true
          stylelint "$@" || echo "âš ï¸  Stylelint found issues (non-blocking warning)"
          exit 0
          ' --


  # From go.yaml
  - repo: local
    hooks:
      - id: go-fmt
        name: go fmt
        entry: sh -c 'gofmt -w "$@"' --
        language: system
        types: [go]
        pass_filenames: true
      - id: go-vet
        name: go vet
        entry: sh -c 'go vet ./...'
        language: system
        types: [go]
        pass_filenames: false
      - id: go-imports
        name: goimports
        entry:
          sh -c 'if command -v goimports >/dev/null 2>&1; then goimports -w "$@"; else go run
          golang.org/x/tools/cmd/goimports@latest -w "$@"; fi' --
        language: system
        types: [go]
        pass_filenames: true
      - id: go-mod-tidy
        name: go mod tidy
        entry: sh -c 'go mod tidy'
        language: system
        files: ^go\.(mod|sum)$
        pass_filenames: false
      - id: golangci-lint
        name: golangci-lint
        entry:
          sh -c 'if command -v golangci-lint >/dev/null 2>&1; then golangci-lint run --timeout=5m;
          else echo "golangci-lint not found, skipping"; fi'
        language: system
        types: [go]
        pass_filenames: false


  # From html.yaml
  # Prettier - HTML formatter (local hook since mirrors-prettier is archived)
  - repo: local
    hooks:
      - id: prettier-html
        name: prettier
        entry: |
          bash -c '
          # Check if prettier is available
          if ! command -v npx >/dev/null 2>&1; then
            echo "npx not found, skipping prettier"
            exit 0
          fi
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          npx prettier@3.4.2 --write "${FILTERED_FILES[@]}"
          ' --
        language: system
        types: [html]


  # From javascript.yaml
  - repo: https://github.com/pre-commit/mirrors-eslint
    rev: v9.15.0
    hooks:
      - id: eslint
        name: eslint (auto-fix, warnings only)
        types: [file]
        types_or: [javascript, jsx, ts, tsx]
        additional_dependencies:
          - eslint@9.15.0
        exclude: ^(node_modules|dist|build)/
        # Skip if no eslint config file exists, and skip autogenerated files
        # Auto-fix runs, but remaining lint issues are warnings (non-blocking)
        entry: |
          bash -c '
          # First check if eslint config exists (prefer flat config, fallback to legacy)
          if [ ! -f eslint.config.js ] && [ ! -f eslint.config.mjs ] && [ ! -f eslint.config.cjs ] && [ ! -f .eslintrc.json ] && [ ! -f .eslintrc.js ] && [ ! -f .eslintrc.yaml ] && [ ! -f .eslintrc.yml ] && [ ! -f .eslintrc.cjs ] && [ ! -f .eslintrc.mjs ] && [ ! -f package.json ]; then
            echo "Skipping eslint: No configuration file found (eslint.config.*, .eslintrc.*, or package.json with eslintConfig)"
            exit 0
          fi
          # Check if package.json has eslintConfig
          if [ -f package.json ] && ! grep -q "\"eslintConfig\"" package.json && [ ! -f eslint.config.js ] && [ ! -f eslint.config.mjs ] && [ ! -f eslint.config.cjs ] && [ ! -f .eslintrc.json ] && [ ! -f .eslintrc.js ] && [ ! -f .eslintrc.yaml ] && [ ! -f .eslintrc.yml ] && [ ! -f .eslintrc.cjs ] && [ ! -f .eslintrc.mjs ]; then
            echo "Skipping eslint: No configuration file found (eslint.config.*, .eslintrc.*, or package.json with eslintConfig)"
            exit 0
          fi
          # Filter out autogenerated files
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          # ESLint 9.0.0 uses flat config by default (eslint.config.js)
          # For legacy .eslintrc.* files, set ESLINT_USE_FLAT_CONFIG=false
          # Auto-fix issues first, then show remaining issues as warnings (non-blocking)
          if [ -f .eslintrc.json ] || [ -f .eslintrc.js ] || [ -f .eslintrc.yaml ] || [ -f .eslintrc.yml ] || [ -f .eslintrc.cjs ] || [ -f .eslintrc.mjs ]; then
            ESLINT_USE_FLAT_CONFIG=false eslint --fix "${FILTERED_FILES[@]}" || true
            ESLINT_USE_FLAT_CONFIG=false eslint "${FILTERED_FILES[@]}" || echo "âš ï¸  ESLint found issues (non-blocking warning)"
          else
            eslint --fix "${FILTERED_FILES[@]}" || true
            eslint "${FILTERED_FILES[@]}" || echo "âš ï¸  ESLint found issues (non-blocking warning)"
          fi
          exit 0
          ' --


  # From json.yaml
  # Prettier - JSON formatter (local hook since mirrors-prettier is archived)
  - repo: local
    hooks:
      - id: prettier-json
        name: prettier
        entry: |
          python3 -c "
          import sys
          import json
          import os
          import subprocess
          from pathlib import Path

          manifest_file = '.sah-defaults-versions.json'
          filtered_files = []

          # Load manifest if it exists
          manifest = {}
          if os.path.exists(manifest_file):
              try:
                  with open(manifest_file) as f:
                      manifest = json.load(f)
              except:
                  pass

          for file_path in sys.argv[1:]:
              # Skip manifest file itself
              if '.sah-defaults-versions.json' in file_path:
                  continue

              file_path_obj = Path(file_path)
              filename = file_path_obj.name

              # For JSON files, check if they're in the manifest (autogenerated)
              if file_path.endswith('.json') and filename in manifest:
                  continue

              # For non-JSON or files not in manifest, check for header
              try:
                  with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                      first_lines = ''.join(f.readline() for _ in range(10))
                      if 'THIS FILE IS AUTOGENERATED' not in first_lines:
                          filtered_files.append(file_path)
              except:
                  # If we can't read it, include it to be safe
                  filtered_files.append(file_path)

          if not filtered_files:
              sys.exit(0)

          # Run prettier on filtered files
          subprocess.run(['npx', 'prettier@3.4.2', '--write'] + filtered_files, check=False)
          " --
        language: system
        types: [json]
        exclude: ^\.sah-defaults-versions\.json$


  # From laravel.yaml
  - repo: local
    hooks:
      # Laravel Pint - Official Laravel code formatter (auto-fix)
      - id: laravel-pint
        name: Laravel Pint (formatting)
        entry: |
          bash -c '
          # Verify this is a Laravel project
          if [ ! -f composer.json ]; then
            echo "Skipping Pint: composer.json not found"
            exit 0
          fi

          if command -v jq >/dev/null 2>&1; then
            HAS_LARAVEL=$(jq -r ".require[\"laravel/framework\"] // .\"require-dev\"[\"laravel/framework\"] // empty" composer.json)
            COMPOSER_TYPE=$(jq -r ".type // empty" composer.json)
          else
            HAS_LARAVEL=$(grep -E "\"laravel/framework\"" composer.json || true)
            COMPOSER_TYPE=$(grep -o "\"type\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" composer.json | sed -n "s/.*\"type\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p" | head -1)
          fi

          if [[ -z "$HAS_LARAVEL" ]] && [[ "$COMPOSER_TYPE" != "laravel" ]] && [[ "$COMPOSER_TYPE" != *"laravel"* ]]; then
            echo "Skipping Pint: Not a Laravel project"
            exit 0
          fi

          # Find or install Pint
          if [ -f vendor/bin/pint ]; then
            PINT=./vendor/bin/pint
          elif command -v pint >/dev/null 2>&1; then
            PINT=pint
          else
            echo "ðŸ“¦ Laravel Pint not found. Installing..."

            # Ensure .gitignore has /vendor/ before installing
            if [ ! -f .gitignore ] || ! grep -qxF "/vendor/" .gitignore 2>/dev/null; then
              echo "/vendor/" >> .gitignore
              echo "âœ… Added /vendor/ to .gitignore"
            fi

            # Install Pint
            composer require --dev laravel/pint --no-interaction --quiet
            if [ -f vendor/bin/pint ]; then
              PINT=./vendor/bin/pint
              echo "âœ… Laravel Pint installed"
            else
              echo "âŒ Failed to install Laravel Pint"
              exit 1
            fi
          fi

          # Run Pint on staged files
          $PINT "$@"
          ' --
        language: system
        types: [php]
        require_serial: false
        pass_filenames: true
        always_run: false

      # Larastan - PHPStan for Laravel (static analysis on staged files only)
      - id: larastan
        name: Larastan (static analysis)
        entry: |
          bash -c '
          # Verify this is a Laravel project
          if [ ! -f composer.json ]; then
            echo "Skipping Larastan: composer.json not found"
            exit 0
          fi

          if command -v jq >/dev/null 2>&1; then
            HAS_LARAVEL=$(jq -r ".require[\"laravel/framework\"] // .\"require-dev\"[\"laravel/framework\"] // empty" composer.json)
            COMPOSER_TYPE=$(jq -r ".type // empty" composer.json)
          else
            HAS_LARAVEL=$(grep -E "\"laravel/framework\"" composer.json || true)
            COMPOSER_TYPE=$(grep -o "\"type\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" composer.json | sed -n "s/.*\"type\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p" | head -1)
          fi

          if [[ -z "$HAS_LARAVEL" ]] && [[ "$COMPOSER_TYPE" != "laravel" ]] && [[ "$COMPOSER_TYPE" != *"laravel"* ]]; then
            echo "Skipping Larastan: Not a Laravel project"
            exit 0
          fi

          # Find or install PHPStan/Larastan
          if [ -f vendor/bin/phpstan ]; then
            PHPSTAN=./vendor/bin/phpstan
          elif command -v phpstan >/dev/null 2>&1; then
            PHPSTAN=phpstan
          else
            echo "ðŸ“¦ Larastan not found. Installing..."

            # Ensure .gitignore has /vendor/ before installing
            if [ ! -f .gitignore ] || ! grep -qxF "/vendor/" .gitignore 2>/dev/null; then
              echo "/vendor/" >> .gitignore
              echo "âœ… Added /vendor/ to .gitignore"
            fi

            # Install Larastan (includes PHPStan)
            composer require --dev larastan/larastan --no-interaction --quiet
            if [ -f vendor/bin/phpstan ]; then
              PHPSTAN=./vendor/bin/phpstan
              echo "âœ… Larastan installed"
            else
              echo "âŒ Failed to install Larastan"
              exit 1
            fi
          fi

          # Check if phpstan.neon or phpstan.neon.dist exists for Larastan config
          PHPSTAN_CONFIG=""
          if [ -f phpstan.neon ]; then
            PHPSTAN_CONFIG="-c phpstan.neon"
          elif [ -f phpstan.neon.dist ]; then
            PHPSTAN_CONFIG="-c phpstan.neon.dist"
          fi

          # Run PHPStan (with Larastan) on staged files only
          # This mimics golangci-lint --new behavior by only analyzing staged files
          $PHPSTAN analyse $PHPSTAN_CONFIG --memory-limit=1G --no-progress "$@"
          ' --
        language: system
        types: [php]
        require_serial: false
        pass_filenames: true
        always_run: false


  # From perl.yaml
  # Perl::Critic - Perl code quality checker
  - repo: local
    hooks:
      - id: perl-critic
        name: Perl::Critic
        entry: perlcritic
        language: system
        types: [perl] # Automatically skips if no Perl files are staged
        args: ["--quiet", "--profile", ".perlcriticrc"]
        exclude: ^(t/|xt/|blib/|_build/|local/|vendor/)

  # Perl::Tidy - Perl code formatter
  - repo: local
    hooks:
      - id: perl-tidy
        name: Perl::Tidy
        entry: perltidy
        language: system
        types: [perl] # Automatically skips if no Perl files are staged
        args: ["--profile=.perltidyrc", "--backup-and-modify-in-place"]
        exclude: ^(t/|xt/|blib/|_build/|local/|vendor/)


  # From php.yaml
  - repo: local
    hooks:
      # PHP-CS-Fixer - Code formatter (auto-fix)
      - id: php-cs-fixer
        name: PHP-CS-Fixer (formatting)
        entry: |
          bash -c '
          # Skip for WordPress and Laravel projects
          if [ -f composer.json ]; then
            if command -v jq >/dev/null 2>&1; then
              COMPOSER_TYPE=$(jq -r ".type // empty" composer.json)
              HAS_LARAVEL=$(jq -r ".require[\"laravel/framework\"] // .\"require-dev\"[\"laravel/framework\"] // empty" composer.json)
            else
              COMPOSER_TYPE=$(grep -o "\"type\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" composer.json | sed -n "s/.*\"type\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p" | head -1)
              HAS_LARAVEL=$(grep -E "\"laravel/framework\"" composer.json || true)
            fi

            if [[ "$COMPOSER_TYPE" == "wordpress-plugin" ]] || [[ "$COMPOSER_TYPE" == "wordpress-theme" ]]; then
              echo "Skipping PHP-CS-Fixer: WordPress project (use WordPress hooks instead)"
              exit 0
            fi

            if [[ -n "$HAS_LARAVEL" ]] || [[ "$COMPOSER_TYPE" == "laravel" ]] || [[ "$COMPOSER_TYPE" == *"laravel"* ]]; then
              echo "Skipping PHP-CS-Fixer: Laravel project (use Laravel Pint instead)"
              exit 0
            fi
          else
            echo "Skipping PHP-CS-Fixer: No composer.json found"
            exit 0
          fi

          # Find or install PHP-CS-Fixer
          if [ -f vendor/bin/php-cs-fixer ]; then
            FIXER=./vendor/bin/php-cs-fixer
          elif command -v php-cs-fixer >/dev/null 2>&1; then
            FIXER=php-cs-fixer
          else
            echo "ðŸ“¦ PHP-CS-Fixer not found. Installing..."

            # Ensure .gitignore has /vendor/ before installing
            if [ ! -f .gitignore ] || ! grep -qxF "/vendor/" .gitignore 2>/dev/null; then
              echo "/vendor/" >> .gitignore
              echo "âœ… Added /vendor/ to .gitignore"
            fi

            # Install PHP-CS-Fixer
            composer require --dev friendsofphp/php-cs-fixer --no-interaction --quiet
            if [ -f vendor/bin/php-cs-fixer ]; then
              FIXER=./vendor/bin/php-cs-fixer
              echo "âœ… PHP-CS-Fixer installed"
            else
              echo "âŒ Failed to install PHP-CS-Fixer"
              exit 1
            fi
          fi

          # Run on staged files
          $FIXER fix --diff --allow-risky=yes "$@" || true
          ' --
        language: system
        types: [php]
        require_serial: false
        pass_filenames: true
        always_run: false

      # PHPStan - Static analysis (runs on staged files only)
      - id: phpstan
        name: PHPStan (static analysis)
        entry: |
          bash -c '
          # Skip for WordPress projects (they typically use different tooling)
          if [ -f composer.json ]; then
            if command -v jq >/dev/null 2>&1; then
              COMPOSER_TYPE=$(jq -r ".type // empty" composer.json)
            else
              COMPOSER_TYPE=$(grep -o "\"type\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" composer.json | sed -n "s/.*\"type\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p" | head -1)
            fi

            if [[ "$COMPOSER_TYPE" == "wordpress-plugin" ]] || [[ "$COMPOSER_TYPE" == "wordpress-theme" ]]; then
              echo "Skipping PHPStan: WordPress project"
              exit 0
            fi
          else
            echo "Skipping PHPStan: No composer.json found"
            exit 0
          fi

          # Find or install PHPStan
          if [ -f vendor/bin/phpstan ]; then
            PHPSTAN=./vendor/bin/phpstan
          elif command -v phpstan >/dev/null 2>&1; then
            PHPSTAN=phpstan
          else
            echo "ðŸ“¦ PHPStan not found. Installing..."

            # Ensure .gitignore has /vendor/ before installing
            if [ ! -f .gitignore ] || ! grep -qxF "/vendor/" .gitignore 2>/dev/null; then
              echo "/vendor/" >> .gitignore
              echo "âœ… Added /vendor/ to .gitignore"
            fi

            # Install PHPStan
            composer require --dev phpstan/phpstan --no-interaction --quiet
            if [ -f vendor/bin/phpstan ]; then
              PHPSTAN=./vendor/bin/phpstan
              echo "âœ… PHPStan installed"
            else
              echo "âŒ Failed to install PHPStan"
              exit 1
            fi
          fi

          # Check if phpstan.neon or phpstan.neon.dist exists for configuration
          PHPSTAN_CONFIG=""
          if [ -f phpstan.neon ]; then
            PHPSTAN_CONFIG="-c phpstan.neon"
          elif [ -f phpstan.neon.dist ]; then
            PHPSTAN_CONFIG="-c phpstan.neon.dist"
          fi

          # Run PHPStan on the staged files only
          # This mimics golangci-lint --new behavior by only analyzing staged files
          $PHPSTAN analyse $PHPSTAN_CONFIG --memory-limit=1G --no-progress "$@"
          ' --
        language: system
        types: [php]
        require_serial: false
        pass_filenames: true
        always_run: false


  # From python.yaml
  # Black - Python code formatter (required)
  - repo: https://github.com/psf/black
    rev: 24.10.0
    hooks:
      - id: black
        language_version: python3
        exclude: ^(migrations|venv|\.venv)/

  # isort - Python import sorter (required)
  - repo: https://github.com/pycqa/isort
    rev: 6.0.0
    hooks:
      - id: isort
        args: ["--profile", "black"]
        exclude: ^(migrations|venv|\.venv)/

  # flake8 - Python linter (warnings only, non-blocking)
  - repo: local
    hooks:
      - id: flake8
        name: flake8 (warnings only)
        language: system
        types: [python]
        exclude: ^(migrations|venv|\.venv)/
        entry: |
          bash -c '
          if ! command -v flake8 >/dev/null 2>&1; then
            echo "flake8 not found, skipping"
            exit 0
          fi
          flake8 --max-line-length=88 --extend-ignore=E203,W503 "$@" || echo "âš ï¸  flake8 found issues (non-blocking warning)"
          exit 0
          ' --


  # From ruby.yaml
  - repo: local
    hooks:
      - id: rubocop
        name: RuboCop
        description: Ruby linter and formatter
        entry: bundle exec rubocop --autocorrect --force-exclusion
        language: system
        types: [ruby]
        exclude: ^(vendor|node_modules|db/schema\.rb)/

      - id: rubocop-lint
        name: RuboCop (lint only)
        description: Ruby linter (no auto-fix, for CI)
        entry: bundle exec rubocop --force-exclusion
        language: system
        types: [ruby]
        exclude: ^(vendor|node_modules|db/schema\.rb)/
        stages: [manual]

      - id: erb-lint
        name: ERB Lint
        description: Lint ERB templates
        entry: bundle exec erblint --autocorrect
        language: system
        types: [erb]
        exclude: ^(vendor|node_modules)/
        require_serial: true


  # From shell.yaml
  # ShellCheck - Shell script static analysis (warning only, non-blocking)
  - repo: local
    hooks:
      - id: shellcheck
        name: shellcheck (warnings only)
        language: system
        types: [shell]
        entry: |
          bash -c '
          if ! command -v shellcheck >/dev/null 2>&1; then
            echo "shellcheck not found, skipping"
            exit 0
          fi
          shellcheck "$@" || echo "âš ï¸  ShellCheck found issues (non-blocking warning)"
          exit 0
          ' --


  # From terraform.yaml
  # Terraform formatting and validation
  - repo: https://github.com/antonbabenko/pre-commit-terraform
    rev: v1.100.0
    hooks:
      - id: terraform_fmt
        args:
          - --args=-recursive

      - id: terraform_validate

  # Terraform documentation generation
  - repo: https://github.com/terraform-docs/terraform-docs
    rev: v0.20.0
    hooks:
      - id: terraform-docs-system


  # From wordpress.yaml
  # WordPress Coding Standards
  - repo: local
    hooks:
      - id: phpcbf
        name: PHP Code Beautifier and Fixer (WordPress Coding Standards)
        entry: |
          bash -c '
          # Check if composer.json exists and has wordpress-plugin or wordpress-theme type
          if [ ! -f composer.json ]; then
            echo "Skipping PHPCBF: composer.json not found"
            exit 0
          fi

          # Check composer.json type using jq if available, otherwise use grep
          if command -v jq >/dev/null 2>&1; then
            COMPOSER_TYPE=$(jq -r ".type // empty" composer.json)
          else
            COMPOSER_TYPE=$(grep -o "\"type\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" composer.json | sed -n "s/.*\"type\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p" | head -1)
          fi

          if [ "$COMPOSER_TYPE" != "wordpress-plugin" ] && [ "$COMPOSER_TYPE" != "wordpress-theme" ]; then
            echo "Skipping PHPCBF: composer.json type is \"$COMPOSER_TYPE\" (expected wordpress-plugin or wordpress-theme)"
            exit 0
          fi

          # Find or install PHPCBF
          if [ -f vendor/bin/phpcbf ]; then
            PHPCBF=./vendor/bin/phpcbf
          elif command -v phpcbf >/dev/null 2>&1; then
            PHPCBF=phpcbf
          else
            echo "ðŸ“¦ PHP_CodeSniffer not found. Installing with WordPress standards..."

            # Ensure .gitignore has /vendor/ before installing
            if [ ! -f .gitignore ] || ! grep -qxF "/vendor/" .gitignore 2>/dev/null; then
              echo "/vendor/" >> .gitignore
              echo "âœ… Added /vendor/ to .gitignore"
            fi

            # Install PHP_CodeSniffer and WordPress standards
            composer require --dev squizlabs/php_codesniffer wp-coding-standards/wpcs --no-interaction --quiet
            if [ -f vendor/bin/phpcbf ]; then
              # Configure PHPCS to use WordPress standards
              ./vendor/bin/phpcs --config-set installed_paths vendor/wp-coding-standards/wpcs 2>/dev/null || true
              PHPCBF=./vendor/bin/phpcbf
              echo "âœ… PHP_CodeSniffer installed with WordPress standards"
            else
              echo "âŒ Failed to install PHP_CodeSniffer"
              exit 1
            fi
          fi

          $PHPCBF --standard=WordPress --extensions=php --ignore="*/vendor/*,*/node_modules/*,*/dist/*,*/build/*" "$@" || true
          ' --
        language: system
        types: [php]
        require_serial: false
        pass_filenames: true
        always_run: false

      - id: phpcs
        name: PHP CodeSniffer (WordPress Coding Standards)
        entry: |
          bash -c '
          # Check if composer.json exists and has wordpress-plugin or wordpress-theme type
          if [ ! -f composer.json ]; then
            echo "Skipping PHPCS: composer.json not found"
            exit 0
          fi

          # Check composer.json type using jq if available, otherwise use grep
          if command -v jq >/dev/null 2>&1; then
            COMPOSER_TYPE=$(jq -r ".type // empty" composer.json)
          else
            COMPOSER_TYPE=$(grep -o "\"type\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" composer.json | sed -n "s/.*\"type\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p" | head -1)
          fi

          if [ "$COMPOSER_TYPE" != "wordpress-plugin" ] && [ "$COMPOSER_TYPE" != "wordpress-theme" ]; then
            echo "Skipping PHPCS: composer.json type is \"$COMPOSER_TYPE\" (expected wordpress-plugin or wordpress-theme)"
            exit 0
          fi

          # Find or install PHPCS
          if [ -f vendor/bin/phpcs ]; then
            PHPCS=./vendor/bin/phpcs
          elif command -v phpcs >/dev/null 2>&1; then
            PHPCS=phpcs
          else
            echo "ðŸ“¦ PHP_CodeSniffer not found. Installing with WordPress standards..."

            # Ensure .gitignore has /vendor/ before installing
            if [ ! -f .gitignore ] || ! grep -qxF "/vendor/" .gitignore 2>/dev/null; then
              echo "/vendor/" >> .gitignore
              echo "âœ… Added /vendor/ to .gitignore"
            fi

            # Install PHP_CodeSniffer and WordPress standards
            composer require --dev squizlabs/php_codesniffer wp-coding-standards/wpcs --no-interaction --quiet
            if [ -f vendor/bin/phpcs ]; then
              # Configure PHPCS to use WordPress standards
              ./vendor/bin/phpcs --config-set installed_paths vendor/wp-coding-standards/wpcs 2>/dev/null || true
              PHPCS=./vendor/bin/phpcs
              echo "âœ… PHP_CodeSniffer installed with WordPress standards"
            else
              echo "âŒ Failed to install PHP_CodeSniffer"
              exit 1
            fi
          fi

          $PHPCS --standard=WordPress --extensions=php --ignore="*/vendor/*,*/node_modules/*,*/dist/*,*/build/*" "$@"
          ' --
        language: system
        types: [php]
        require_serial: false
        pass_filenames: true
        always_run: false


  # From xml.yaml
  # xmllint - XML validator and formatter (local hook for proper in-place formatting)
  - repo: local
    hooks:
      - id: format-xmllint
        name: Formats XML files
        entry: |
          bash -c '
          # Check if xmllint is available
          if ! command -v xmllint >/dev/null 2>&1; then
            echo "xmllint not found, skipping"
            exit 0
          fi
          FILTERED_FILES=()
          for file in "$@"; do
            # Skip autogenerated files
            if head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              continue
            fi
            FILTERED_FILES+=("$file")
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          # Format each file in place using temp file (xmllint does not support -i)
          for f in "${FILTERED_FILES[@]}"; do
            xmllint --format "$f" > "$f.xmltmp" 2>/dev/null && mv "$f.xmltmp" "$f" || rm -f "$f.xmltmp"
          done
          ' --
        language: system
        types: [xml]
        exclude: \.svg$


  # From yaml-markdown.yaml
  # Prettier - YAML and Markdown formatter (local hook since mirrors-prettier is archived)
  - repo: local
    hooks:
      - id: prettier-yaml-markdown
        name: prettier
        entry: |
          bash -c '
          # Check if prettier is available
          if ! command -v npx >/dev/null 2>&1; then
            echo "npx not found, skipping prettier"
            exit 0
          fi
          FILTERED_FILES=()
          for file in "$@"; do
            if ! head -10 "$file" 2>/dev/null | grep -q "THIS FILE IS AUTOGENERATED"; then
              FILTERED_FILES+=("$file")
            fi
          done
          if [ ${#FILTERED_FILES[@]} -eq 0 ]; then
            exit 0
          fi
          npx prettier@3.4.2 --write "${FILTERED_FILES[@]}"
          ' --
        language: system
        types_or: [yaml, markdown]
        exclude: ^(CHANGELOG|LICENSE)



# === CUSTOM HOOKS (SAFE TO MODIFY BELOW) ===
# Add repo-specific hooks here.